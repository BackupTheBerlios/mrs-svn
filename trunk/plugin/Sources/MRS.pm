# This file was automatically generated by SWIG
package MRS;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package MRSc;
bootstrap MRS;
package MRS;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package MRS;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package MRS;

*errstr = *MRSc::errstr;

############# Class : MRS::MStringIterator ##############

package MRS::MStringIterator;
@ISA = qw( MRS );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = MRSc::new_MStringIterator(@_);
    bless $self, $pkg if defined($self);
}

*Next = *MRSc::MStringIterator_Next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        MRSc::delete_MStringIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : MRS::MDatabank ##############

package MRS::MDatabank;
@ISA = qw( MRS );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = MRSc::new_MDatabank(@_);
    bless $self, $pkg if defined($self);
}

*Create = *MRSc::MDatabank_Create;
*Merge = *MRSc::MDatabank_Merge;
*Count = *MRSc::MDatabank_Count;
*GetVersion = *MRSc::MDatabank_GetVersion;
*DumpInfo = *MRSc::MDatabank_DumpInfo;
*CountForKey = *MRSc::MDatabank_CountForKey;
*Find = *MRSc::MDatabank_Find;
*Get = *MRSc::MDatabank_Get;
*Index = *MRSc::MDatabank_Index;
*Indices = *MRSc::MDatabank_Indices;
*SuggestCorrection = *MRSc::MDatabank_SuggestCorrection;
*Store = *MRSc::MDatabank_Store;
*IndexText = *MRSc::MDatabank_IndexText;
*IndexTextAndNumbers = *MRSc::MDatabank_IndexTextAndNumbers;
*IndexWord = *MRSc::MDatabank_IndexWord;
*IndexValue = *MRSc::MDatabank_IndexValue;
*IndexWordWithWeight = *MRSc::MDatabank_IndexWordWithWeight;
*IndexDate = *MRSc::MDatabank_IndexDate;
*IndexNumber = *MRSc::MDatabank_IndexNumber;
*FlushDocument = *MRSc::MDatabank_FlushDocument;
*SetVersion = *MRSc::MDatabank_SetVersion;
*Finish = *MRSc::MDatabank_Finish;
*CreateDictionary = *MRSc::MDatabank_CreateDictionary;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        MRSc::delete_MDatabank($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : MRS::MQueryResults ##############

package MRS::MQueryResults;
@ISA = qw( MRS );
%OWNER = ();
%ITERATORS = ();
*Next = *MRSc::MQueryResults_Next;
*Skip = *MRSc::MQueryResults_Skip;
*Count = *MRSc::MQueryResults_Count;
sub new {
    my $pkg = shift;
    my $self = MRSc::new_MQueryResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        MRSc::delete_MQueryResults($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : MRS::MKeys ##############

package MRS::MKeys;
@ISA = qw( MRS );
%OWNER = ();
%ITERATORS = ();
*Next = *MRSc::MKeys_Next;
*Skip = *MRSc::MKeys_Skip;
sub new {
    my $pkg = shift;
    my $self = MRSc::new_MKeys(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        MRSc::delete_MKeys($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : MRS::MIndex ##############

package MRS::MIndex;
@ISA = qw( MRS );
%OWNER = ();
%ITERATORS = ();
*Code = *MRSc::MIndex_Code;
*Type = *MRSc::MIndex_Type;
*Count = *MRSc::MIndex_Count;
*Keys = *MRSc::MIndex_Keys;
*FindKey = *MRSc::MIndex_FindKey;
sub new {
    my $pkg = shift;
    my $self = MRSc::new_MIndex(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        MRSc::delete_MIndex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : MRS::MIndices ##############

package MRS::MIndices;
@ISA = qw( MRS );
%OWNER = ();
%ITERATORS = ();
*Next = *MRSc::MIndices_Next;
sub new {
    my $pkg = shift;
    my $self = MRSc::new_MIndices(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        MRSc::delete_MIndices($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package MRS;

*gErrStr = *MRSc::gErrStr;
*VERBOSE = *MRSc::VERBOSE;
*THREADS = *MRSc::THREADS;
*COMPRESSION = *MRSc::COMPRESSION;
*COMPRESSION_LEVEL = *MRSc::COMPRESSION_LEVEL;
*COMPRESSION_DICTIONARY = *MRSc::COMPRESSION_DICTIONARY;
1;
